# Lessons

- When asked to remove unspecified details, keep explicitly requested sections unless told to delete them.
- If a user reverses a structural change (e.g., remove sections then restore), confirm intent before collapsing content further.
- If the user clarifies a protocol requirement, remove any added constraints and align prompts/UI exactly to the clarified behavior.
- When admin routes are corrected, update both the route implementation and README references together.
- When improving prompt quality, avoid globally hardening requirements unless requested; scope strict evidence requirements to the exact thread type or action the user specified.
- When adding new UI microcopy/interactions, keep labels in English unless the user explicitly requests another language and prefer text-link style when the user asks for non-button controls.
- When Etherscan source payloads include wrapper JSON (e.g., `{{ ... }}`), extract and render only `sources[*].content`; do not expose metadata blocks like `language` or `settings` in user-facing system threads.
- If the user requests specific payload fields to be shown (e.g., `libraries`), include them explicitly with readable formatting rather than assuming only code files are needed.
- When making code changes in this repo, create a commit for each completed change set without waiting for additional reminders.
- For status/action controls in SNS UI, keep option button styles visually consistent and place controls where the user interacts with current state (inline in the thread card) when explicitly requested.
- When ownership-sensitive actions are requested, enforce wallet matching at both API and UI interaction points, including a check against the currently connected wallet account.
- If the user asks for mismatch handling via disabled controls instead of errors, suppress mismatch-specific messages and enforce via disabled UI state.
- After a user correction on search scope (e.g., community id vs thread id), update both backend query logic and UI hint text together to keep behavior and UX aligned.
- When unifying list-card layouts across pages, verify metadata parity (created time/comment count/thread id) and ensure both query payloads and render components are updated together.
- If users request strict layout unification across pages, enforce it via a single shared card component import rather than duplicating similar JSX in multiple feed components.
- For visible filter controls in SNS, avoid default checkbox look; use polished chip-based controls with clear active/hover/focus states when the user asks for modern UI quality.
- If tag styles must be unified, render all related tags with the same base class/component instead of maintaining parallel custom tag classes.
- When users ask for cleaner filtering UX, favor compact dropdown multi-select controls (with persistent checkbox options) over wide inline checklists and shorten labels to high-signal words like `Type`.
- When custom checkboxes live inside a generic `.field` container, guard against global `.field input` styles by using more specific selectors (e.g., `.field .thread-type-dropdown-item input.thread-type-checkbox`) and verify rendered controls are not stretched.
- If a filter UI includes decorative controls users do not actually need (e.g., redundant checkboxes), remove them and keep selection affordance through clear row-level selected states.
- For owner-only actions, do not trust stored session wallet alone; reconcile it with the currently connected wallet account and disable privileged actions when they diverge.
- For compact header widgets, render transient error text as absolute-positioned bubbles/toasts so status messages do not break surrounding layout flow.
- In thread-card status controls, do not render extra guidance/session messages in-flow unless explicitly requested; keep the control surface minimal to avoid layout breakage.
- Keep owner authentication UX consistent across request/report actions: if status control uses click-to-sign-in, comment posting should use the same pattern instead of separate sign-in/out panels.
- When users ask for app-wide wallet-login enforcement, implement a centralized guard in layout plus a dedicated login route instead of patching each button individually.
- When product terminology is corrected (e.g., login -> sign-in), update both UI copy and route targets together while preserving backward compatibility redirects.
- If the user explicitly asks to fully replace a route/term, remove legacy compatibility paths instead of keeping redirects.
- For ID-reference UX in thread/comment bodies, resolve IDs via a single API and render links in the shared content formatter; add DOM anchors on comment cards for deep links.
- For strict auth gating requests, include top-navigation links in the redirect guard and verify they are not excluded by selector scope (e.g., plain anchors vs button-styled links).
- For constrained single-card auth screens, keep the layout minimal but still add explicitly requested navigation actions (e.g., Home button) without reintroducing full chrome.
- If connect and owner-auth are expected together, ensure both sign-in entry points (dedicated sign-in page and top wallet switch) run the same signature-based session creation path.
- For third-party issue submission without OAuth/PAT flow, provide an owner-authenticated prefilled `issues/new` draft URL path to keep functionality usable and avoid blocked server-side issue creation.
- In React effects, do not place unstable inline objects (e.g., auth headers) into callback dependencies; memoize them with `useMemo([token])` to prevent unintended auto-refresh loops.
- For agent registration scope, do not hardcode one-agent-per-wallet assumptions; model and API constraints should follow the required granularity `(wallet, community)` when community-specific agent control is needed.
- For button-triggered transient status bubbles, always anchor position to the clicked element (`event.currentTarget`) instead of fixed viewport coordinates, and verify every button path passes the anchor.
- In React `onChange` handlers, do not read `event.currentTarget.value` inside functional state updaters; capture `const { value } = event.currentTarget` first, then use `value` in `setState(prev => ...)`.
