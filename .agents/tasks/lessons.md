# Lessons

- For third-party console UI guidance (e.g., Neon), do not assert menu labels/locations without verification; when uncertain, provide qualified navigation paths and ask for screenshot/context instead of definitive claims.
- When a user asks to keep README format minimal, preserve the existing README structure and update only `Current Development Status` plus usage-command sections; avoid full-document expansion.
- When report-status badges are intended as compact visual markers, use concise labels (`ISSUED` / `NOT ISSUED`) and keep the corresponding status-filter option strings in sync with the badge text source.
- For report-thread GitHub issue actions, do not hide controls when `githubRepositoryUrl` is missing; keep buttons visible in disabled state with an explicit reason, and always render both positive/negative issue-status badges on report cards.
- For “single-card rotating recent activity” requirements, keep polling for freshness but decouple display rotation (fixed interval) from fetch updates so users see deterministic sequential playback.
- When users request a control relocation (e.g., from section footer to directly under a hero/card), move the component exactly to that structural position and adjust width/CTA prominence as part of the same change.
- For dashboard/stat-card requests, implement the exact metric set and display order from the user (including new time-window metrics like `in last 24H`) instead of preserving prior ordering.
- For metadata fields that users expect to always see (e.g., `created at`), render explicit fallback text instead of conditionally hiding the field when source timestamps are missing/invalid.
- Keep user-error logging policy in a dedicated observability/logging skill (not `security-boundary-guardrails`), and leave only cross-boundary security constraints in the security skill.
- For global status bubbles with auto-dismiss timers, wire explicit hover-reset behavior for both the originating trigger control and the bubble surface when users ask for dismiss-countdown control.
- When users request single-source constants, remove duplicated value tables from skill docs and keep skills pointing to the authoritative code/DB source locations instead.
- For anti-DoS admission policies, keep temporary qualification constants in a dedicated code policy module and mirror the same values in `.agents/skills/security-boundary-guardrails/SKILL.md` as the source-of-truth table.
- If a user asks to match thread-body read-more behavior on community description, use the same truncation threshold (`maxChars`) on the community detail description renderer so the toggle appears at the same content length.
- When users request body-rendering consistency, route community descriptions through the same shared rich-text renderer used by thread/comment bodies and extend that single renderer (e.g., markdown table support) instead of adding one-off renderers per surface.
- For community contract lifecycle changes, enforce a single canonical `SYSTEM` thread per community and record all contract/description mutations as `SYSTEM` comments on that thread instead of creating new `SYSTEM` threads.
- For adjacent header controls, size new toggle labels and check indicators to match nearby filter-label typography so the visual rhythm stays consistent.
- If a user revises direction from “replace” to “add alongside existing flow,” preserve the existing path and implement the new capability in parallel instead of continuing with replacement assumptions.
- For optional automation secrets (e.g., GitHub token), keep startup non-blocking and treat missing values as explicit feature-disable (`skip`) rather than operational failure.
- When adding new header filters, avoid raw browser checkbox styling; match SNS visual language with a styled pill toggle and explicit action-oriented wording.
- For dense community cards, render creator metadata on a separate line from the title instead of right-aligning it on the same row.
- For community stat cards, follow requested metric labels and order exactly (e.g., `Threads -> Reports -> Comments`) instead of keeping prior wording/sequence.
- For tile-layout requests, do not rely on `auto-fit` alone; enforce explicit responsive column breakpoints so desktop visibly renders multi-column tiles.
- When asked to remove page-header badges, remove only the hero title/description label badges across SNS subpages and preserve functional/informational badges used in metadata rows.
- For strict badge-order requests, enforce the exact left-to-right sequence in the shared card component (`ThreadFeedCard`) so every page inherits the same corrected order.
- When proposing guardrail skill sets, include explicit UI design-layout guardrails (page-level + component-level) whenever the project has active SNS/frontend surface area, rather than treating UI consistency as optional.
- Place project-local reusable skills under `.agents/skills/` (not repository-root `skills/`) so team conventions and agent discovery expectations stay aligned.
- When asked to remove unspecified details, keep explicitly requested sections unless told to delete them.
- If a user reverses a structural change (e.g., remove sections then restore), confirm intent before collapsing content further.
- If the user clarifies a protocol requirement, remove any added constraints and align prompts/UI exactly to the clarified behavior.
- When admin routes are corrected, update both the route implementation and README references together.
- When improving prompt quality, avoid globally hardening requirements unless requested; scope strict evidence requirements to the exact thread type or action the user specified.
- When adding new UI microcopy/interactions, keep labels in English unless the user explicitly requests another language and prefer text-link style when the user asks for non-button controls.
- When Etherscan source payloads include wrapper JSON (e.g., `{{ ... }}`), extract and render only `sources[*].content`; do not expose metadata blocks like `language` or `settings` in user-facing system threads.
- If the user requests specific payload fields to be shown (e.g., `libraries`), include them explicitly with readable formatting rather than assuming only code files are needed.
- When making code changes in this repo, create a commit for each completed change set without waiting for additional reminders.
- In this repository, prioritize `AGENTS.md` workflow rules over personal caution defaults: after implementing requested changes, commit in the same turn unless the user explicitly asks not to commit.
- For Next.js app-router pages that are statically prerendered, avoid placing `useSearchParams` in shared/global client components (layout-level guards); either wrap with `Suspense` explicitly or remove the hook in favor of client-only `window.location` parsing where appropriate.
- For status/action controls in SNS UI, keep option button styles visually consistent and place controls where the user interacts with current state (inline in the thread card) when explicitly requested.
- When ownership-sensitive actions are requested, enforce wallet matching at both API and UI interaction points, including a check against the currently connected wallet account.
- If the user asks for mismatch handling via disabled controls instead of errors, suppress mismatch-specific messages and enforce via disabled UI state.
- After a user correction on search scope (e.g., community id vs thread id), update both backend query logic and UI hint text together to keep behavior and UX aligned.
- When unifying list-card layouts across pages, verify metadata parity (created time/comment count/thread id) and ensure both query payloads and render components are updated together.
- If users request strict layout unification across pages, enforce it via a single shared card component import rather than duplicating similar JSX in multiple feed components.
- For visible filter controls in SNS, avoid default checkbox look; use polished chip-based controls with clear active/hover/focus states when the user asks for modern UI quality.
- If tag styles must be unified, render all related tags with the same base class/component instead of maintaining parallel custom tag classes.
- When users ask for cleaner filtering UX, favor compact dropdown multi-select controls (with persistent checkbox options) over wide inline checklists and shorten labels to high-signal words like `Type`.
- When custom checkboxes live inside a generic `.field` container, guard against global `.field input` styles by using more specific selectors (e.g., `.field .thread-type-dropdown-item input.thread-type-checkbox`) and verify rendered controls are not stretched.
- If a filter UI includes decorative controls users do not actually need (e.g., redundant checkboxes), remove them and keep selection affordance through clear row-level selected states.
- For owner-only actions, do not trust stored session wallet alone; reconcile it with the currently connected wallet account and disable privileged actions when they diverge.
- For compact header widgets, render transient error text as absolute-positioned bubbles/toasts so status messages do not break surrounding layout flow.
- In thread-card status controls, do not render extra guidance/session messages in-flow unless explicitly requested; keep the control surface minimal to avoid layout breakage.
- Keep owner authentication UX consistent across request/report actions: if status control uses click-to-sign-in, comment posting should use the same pattern instead of separate sign-in/out panels.
- When users ask for app-wide wallet-login enforcement, implement a centralized guard in layout plus a dedicated login route instead of patching each button individually.
- When product terminology is corrected (e.g., login -> sign-in), update both UI copy and route targets together while preserving backward compatibility redirects.
- If the user explicitly asks to fully replace a route/term, remove legacy compatibility paths instead of keeping redirects.
- For ID-reference UX in thread/comment bodies, resolve IDs via a single API and render links in the shared content formatter; add DOM anchors on comment cards for deep links.
- For strict auth gating requests, include top-navigation links in the redirect guard and verify they are not excluded by selector scope (e.g., plain anchors vs button-styled links).
- For constrained single-card auth screens, keep the layout minimal but still add explicitly requested navigation actions (e.g., Home button) without reintroducing full chrome.
- If connect and owner-auth are expected together, ensure both sign-in entry points (dedicated sign-in page and top wallet switch) run the same signature-based session creation path.
- For third-party issue submission without OAuth/PAT flow, provide an owner-authenticated prefilled `issues/new` draft URL path to keep functionality usable and avoid blocked server-side issue creation.
- In React effects, do not place unstable inline objects (e.g., auth headers) into callback dependencies; memoize them with `useMemo([token])` to prevent unintended auto-refresh loops.
- For agent registration scope, do not hardcode one-agent-per-wallet assumptions; model and API constraints should follow the required granularity `(wallet, community)` when community-specific agent control is needed.
- For button-triggered transient status bubbles, always anchor position to the clicked element (`event.currentTarget`) instead of fixed viewport coordinates, and verify every button path passes the anchor.
- In React `onChange` handlers, do not read `event.currentTarget.value` inside functional state updaters; capture `const { value } = event.currentTarget` first, then use `value` in `setState(prev => ...)`.
- Re-validate the same React event-safety rule for every new dropdown/input handler: even helper calls like `normalizeX(event.currentTarget.value)` inside functional updaters can crash with `Cannot read properties of null (reading 'value')`.
- Do not expose internal/security state banners by default (e.g., signature readiness/encrypted loaded) unless explicitly requested; keep UX focused on actionable controls and result feedback.
- For validation errors triggered by a specific action button (e.g., missing password on encrypt), use anchored bubble/toast feedback at the button instead of inline status text that shifts card layout.
- In `Security Sensitive` management UI, avoid card-level status paragraphs entirely; use anchored bubbles for load/decrypt/signature/encrypt outcomes so no internal workflow text remains in layout.
- For `Encrypt & Save` in manage-agents security UI, use error-only feedback: show bubble on failures, and show nothing on successful save unless explicitly requested.
- When a user requests SNS-wide popup status behavior across many buttons, prefer one global bridge (status mutation observer + shared bubble host) over piecemeal per-component rewrites to keep behavior consistent.
- When a user updates feedback policy globally (e.g., show both success and error popups), re-align any earlier per-action exceptions to the new global rule.
- If a global popup-feedback policy is required, actions that previously returned silently must emit explicit status text/events; otherwise global popup bridges cannot surface outcomes for those buttons.
- For launcher/network target fields, remove free-form manual inputs when values must come from runtime discovery; enforce detected-only selection and guard execution when no detected target exists.
- When a prerequisite can be derived on demand (e.g., signature required by decrypt/encrypt), remove manual preparatory buttons and trigger the prerequisite automatically from the action button flow.
- For launch/start actions, validate completeness across all prerequisite form sections (not just action-local fields) and return one clear missing-fields popup before any network call.
- Keep static informational text out of `.status` class when using a global status-popup bridge; reserve `.status` for actionable operation results only.
- When splitting config sources between UI payload and server DB, pass a stable identifier (`agentId`) and fetch authoritative general data server-side; only send sensitive/runtime inputs from UI payload.
- With global status-to-bubble bridging enabled, silence non-user-initiated status updates on initial data hydration (e.g., page-entry auto loads) to avoid noisy popups that appear detached from user actions.
- For copy-edit requests, apply the user's exact target wording first, then run a localized sweep of adjacent UI status strings to fix grammar inconsistencies in the same user flow.
- In global status-to-popup bridges, only emit popups when status updates are causally tied to a recent button click anchor; suppress page-load/background status changes to prevent stray floating bubbles.
- In global status-bubble anchoring, capture click-time button geometry as a fallback snapshot and place the bubble above that anchor so unmount/re-render after success cannot move the popup to unrelated viewport positions.
- When users ask to enforce a recurring UI behavior (e.g., popup anchoring), codify it in the relevant `.agents/skills/*/SKILL.md` guardrail instead of keeping it only as an implementation detail.
- For requested form-structure changes, preserve existing behaviors and handlers while reordering UI blocks; use small layout utilities (e.g., full-width button class) instead of rewriting interaction logic.
- For staged action UX (e.g., click button -> inline password -> confirm), model explicit UI modes and close the mode on outside `pointerdown`/`focusin` so transient inputs do not linger or conflict with other controls.
- When adding inline input rows outside `.field`, reuse the same global control selectors (base, focus, read-only, focus-visible) so ad-hoc inputs do not fall back to mismatched browser-default styling.
- For user-requested UI copy changes, apply the exact requested phrasing in rendered labels instead of shorthand values-only text.
- When a user reverses a UI copy decision for readability, roll back only the copy change immediately and avoid adding alternative wording unless requested.
- For provider-specific form requirements, use conditional layout rendering and keep the specialized UI visible for as long as that provider remains selected.
- For npm root scripts requiring shorthand runtime args (e.g., `-p`), use a small Node wrapper that normalizes multiple arg formats and forwards explicit flags to the workspace command.
- If the user explicitly says not to run a tool/workflow (e.g., local `vercel build`), stop using it immediately and continue with permitted alternatives only.
- For runner launch validation, require only values the runner actually consumes at start; do not block execution on encryption/decryption password fields.
- When adding provider-specific config like LiteLLM base URL, persist it in DB via General API, reload it into UI state on Load from DB, and normalize values (e.g., strip trailing slash) at save time.
- For local launcher interoperability, include critical runtime credentials through both the primary encoded payload and explicit config fields when older launcher paths may still parse only explicit fields.
- If the user requires deterministic LLM behavior constraints (e.g., no temperature), remove the parameter from all provider payloads rather than applying model-specific exceptions.
- When a user asks for full observability, instrument all boundaries (launcher API, SNS network, LLM network) plus engine internal state transitions with structured logs instead of partial point fixes.
- If the user refines observability requirements to separate channels, route full traces to file sinks and keep terminal output to concise operational summaries.
- When asked to match an existing logging UX, inspect the original implementation format (timestamp/direction/action/content) and replicate that structure verbatim in new runtime logs.
- When aligning one app’s prompt behavior with another, migrate both prompt content and prompt-loading mechanism to file-based `.md` management rather than only copying text inline.
- For parity migrations between two runtimes, align execution semantics first (LLM call policy, parsing fallback, action guards, failure handling) and document any unavoidable backend-architecture deltas explicitly.
- When the user asks to execute a documented security plan, implement the checklist items directly in code (not just analysis), then update the same document with completion status and explicit remaining follow-ups.
- For runner/auth security changes, validate against the project's 24/7 local-runner constraint first; avoid designs that couple runner liveness to short-lived browser delegation tokens.
- After `setState`, do not immediately run dependent validation/network logic off the old state snapshot; pass freshly produced values (e.g., decrypted secrets) directly to the next function to avoid false error popups from stale closures.
- In `useEffect` bootstrap flows, avoid depending on callbacks whose identity changes from state they themselves update; this can create self-triggered loops (e.g., repeated load/detect cycles). Keep detection/status queries decoupled and guard redundant `setState` writes.
- When a user asks a new UI control to match an existing in-product design, reuse the same component structure/classes (e.g., dropdown trigger/menu/item) instead of introducing a parallel visual pattern.
- If information is technically present in UI but users still miss it, make it explicit with clear labels (e.g., `Community: ...`) instead of subtle/plain text placement.
- For cross-page visual consistency requests, extract shared UI (e.g., comment card) and reuse it instead of keeping separate ad-hoc markup per page.
- For “layout unification” requests on threads, drive all thread surfaces from `ThreadFeedCard` and adapt data contracts instead of recreating near-identical JSX per page.
- For parity requests between two card surfaces, match both header presence and footer metadata structure (not just colors/spacing), including id-slot semantics (`thread id` vs `comment id`).
- When users demand code-level “complete unification,” audit and replace leftover preview/snippet render paths too, then codify the rule in the relevant skill document.
- When users tighten anti-duplication policy for agent posting, encode strict no-op behavior (`[]`) for duplicate root-cause/reproduction/impact in both `agent.md` and `user.md`, not only in one prompt.
- When producing or updating documentation in this repository, write documents in English by default unless the user explicitly asks for another language.
- When users require "always-run" preprocessing for runtime and build commands, embed that preprocessing directly into the primary commands (`serve`, `run-once`, `build`) and remove intermediate helper commands to keep the command surface minimal.
- When users specify exact command semantics/names (e.g., `serve` -> `dev`, `start` as binary launcher, no preprocessing on `run-once`), apply that contract literally across both workspace and root scripts and remove legacy aliases.
- For `pkg@5.8.1` runner binaries, use supported targets (`node18-*`) and keep local scripts plus release workflow targets aligned to avoid runtime build failures like `No available node version satisfies 'node20'`.
- When adding binary launcher wrappers, preserve CLI ergonomics from prior dev commands (support `-s/-p` short flags and normalize them to the runner's long options) so existing operator habits do not break.
